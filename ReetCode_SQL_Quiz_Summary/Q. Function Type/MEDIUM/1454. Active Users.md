## [1454. Active Users]  


### Table: Accounts


| Column Name   | Type    |
|---------------|---------|
| id            | int     |
| name          | varchar |

id is the primary key (column with unique values) for this table.  
This table contains the account id and the user name of each account.  
 

### Table: Logins


| Column Name   | Type    |
|---------------|---------|
| id            | int     |
| login_date    | date    |

This table may contain duplicate rows.  
This table contains the account id of the user who logged in and the login date. A user may log in multiple times in the day.  
 
## Problem 

Active users are those who logged in to their accounts for five or more consecutive days.  

Write a solution to find the id and the name of active users.  

Return the result table ordered by id.  

The result format is in the following example.  
 
 

## Example 1:

### Input: 

Accounts table:


| id | name     |
|----|----------|
| 1  | Winston  |
| 7  | Jonathan |

Logins table:

| id | login_date |
|----|------------|
| 7  | 2020-05-30 |
| 1  | 2020-05-30 |
| 7  | 2020-05-31 |
| 7  | 2020-06-01 |
| 7  | 2020-06-02 |
| 7  | 2020-06-02 |
| 7  | 2020-06-03 |
| 1  | 2020-06-07 |
| 7  | 2020-06-10 |

### Output: 

| id | name     |
|----|----------|
| 7  | Jonathan |

### Explanation: 

* User Winston with id = 1 logged in 2 times only in 2 different days, so, Winston is not an active user.
* User Jonathan with id = 7 logged in 7 times in 6 different days, five of them were consecutive days, so, Jonathan is an active user.
* Follow up: Could you write a general solution if the active users are those who logged in to their accounts for n or more consecutive days?



<br/>

---

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>


## ğŸŸ¢ ë‹µì•ˆ (SQL Solution)

```sql
with CTE AS (
    SELECT id, login_date,
        dense_rank() OVER(PARTITION BY id ORDER BY login_date) AS row_num
    FROM Logins),

CTE2 AS (
    SELECT id, login_date, row_num,  
       DATE_ADD(login_date, INTERVAL -row_num DAY) AS date_group
    FROM CTE)

SELECT DISTINCT(CTE2.id), A1.name
FROM CTE2 
JOIN Accounts A1 ON CTE2.id = A1.id
GROUP BY CTE2.id, CTE2.date_group
HAVING DATEDIFF(MAX(CTE2.login_date), MIN(CTE2.login_date)) >= 4
ORDER BY CTE2.ID
```

## ğŸŸ¢ í’€ì´ (Discription)

í”íˆ ì´ëŸ° ë¬¸ì œë¥¼ `Gap & Islands'` ìœ í˜•ì˜ ë¬¸ì œë¼ê³  ë¶€ë¦…ë‹ˆë‹¤.
ê°„ë‹¨í•˜ê²Œ ì„¤ëª…í•˜ìë©´, ì—°ì†ë˜ì–´ ìˆëŠ” ê°’ì˜ ê°œìˆ˜ë¥¼ ì§‘ê³„í•  ë•Œ ë§ì´ ì‚¬ìš©í•˜ëŠ” í˜•íƒœì˜ SQL êµ¬í˜„ ë°©ë²•ì…ë‹ˆë‹¤.  
ì´ë²ˆ ë¬¸ì œì—ì„œë„ ë™ì¼í•˜ê²Œ, íŠ¹ì • ì¼ìì˜ ë²”ìœ„ì•ˆì—ì„œ ì—°ì†ë˜ëŠ” ë‚ ì§œì˜ ê°¯ìˆ˜ë¥¼ êµ¬í•´ì•¼ í•˜ëŠ” ë¬¸ì œì´ê¸° ë•Œë¬¸ì— ë™ì¼í•œ ë°©ë²•ìœ¼ë¡œ ë‹µì„ ë„ì¶œí•©ë‹ˆë‹¤.  

* [ì°¸ê³  ë§í¬](https://livebook.manning.com/book/sql-server-mvp-deep-dives/chapter-5/39)


<br/>

#### STEP. 1 [dense_rank()ë¡œ íŠ¹ì • ë°ì´í„°ì˜ ì—°ì†ë¨ì„ í™•ì¸]

```sql
SELECT id, login_date,
    dense_rank() OVER(PARTITION BY id ORDER BY login_date) AS row_num
FROM Logins
```

| id | login_date | row_num |
| -- | ---------- | ------- |
| 1  | 2020-05-30 | 1       |
| 1  | 2020-06-07 | 2       |
| 7  | 2020-05-30 | 1       |
| 7  | 2020-05-31 | 2       |
| 7  | 2020-06-01 | 3       |
| 7  | 2020-06-02 | 4       |
| 7  | 2020-06-02 | 4       |
| 7  | 2020-06-03 | 5       |
| 7  | 2020-06-10 | 6       |

ìœ„ì™€ ê°™ì´, `ID`ë¥¼ ê¸°ì¤€ìœ¼ë¡œ, `login_date`ì˜ ì—°ì†ë¨ì„ `DENSE_RANK`ë¥¼ í†µí•´ì„œ í™•ì¸í•©ë‹ˆë‹¤.  
ì¶œë ¥ëœ ë°ì´í„°ì™€ ê°™ì´ `ID` ë³„ë¡œ ì—°ì†ì„±ì„ row_num ì»¬ëŸ¼ìœ¼ë¡œ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤.

<br/>

---

#### STEP. 2 [DATEDIFF, DATA_ADDë¥¼ í†µí•´ì„œ Duration ë„ì¶œ]  

```sql
with CTE AS (
    SELECT id, login_date,
        dense_rank() OVER(PARTITION BY id ORDER BY login_date) AS row_num
    FROM Logins
    )

SELECT id, login_date, row_num,  
       DATE_ADD(login_date, INTERVAL -row_num DAY) AS date_group
FROM CTE
```

| id | login_date | row_num | date_group |
| -- | ---------- | ------- | ---------- |
| 1  | 2020-05-30 | 1       | 2020-05-29 |
| 1  | 2020-06-07 | 2       | 2020-06-05 |
| 7  | 2020-05-30 | 1       | 2020-05-29 |
| 7  | 2020-05-31 | 2       | 2020-05-29 |
| 7  | 2020-06-01 | 3       | 2020-05-29 |
| 7  | 2020-06-02 | 4       | 2020-05-29 |
| 7  | 2020-06-02 | 4       | 2020-05-29 |
| 7  | 2020-06-03 | 5       | 2020-05-29 |
| 7  | 2020-06-10 | 6       | 2020-06-04 |  

ê¸°ì¡´ `login_date` ì»¬ëŸ¼ì—ì„œ ê³„ì† ì¦ê°€í•˜ëŠ” ì—°ì†ì„±ì„ ë‚˜íƒ€ë‚´ëŠ” `row_num`ì˜ ì°¨ì´ë¥¼ ê³„ì‚°í•˜ë©´
ì—°ì†ì„±ì„ ê°€ì§€ê³  ìˆëŠ” Groupì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.    

* 2020-05-30 - 1 = 2020-05-29 (row num - 1)
* 2020-05-31 - 2 = 2020-05-29 (row num - 2) ì™€ ê°™ì´, dateê°€ 1ì”© ëŠ˜ì–´ë‚œ ê²½ìš°, rownumë„ ë™ì¼í•˜ê²Œ 1ì”© ëŠ˜ì–´ë‚¨  

<br/>

#### STEP. 3 [GROUP BY, HAVING]  

```sql
SELECT *
FROM CTE2 
JOIN Accounts A1 ON CTE2.id = A1.id
GROUP BY CTE2.id, CTE2.date_group
HAVING DATEDIFF(MAX(CTE2.login_date), MIN(CTE2.login_date)) >= 4
ORDER BY CTE2.ID
```

| id | login_date | row_num | date_group | id | name     |
| -- | ---------- | ------- | ---------- | -- | -------- |
| 7  | 2020-05-30 | 1       | 2020-05-29 | 7  | Jonathan |

ì•Œì•„ë³´ê¸° ì‰½ê²Œ, ì •ë‹µì—ì„œ *ë¡œ ì¶œë ¥ ê²°ê³¼ë¥¼ ë°”ê¿¨ìŠµë‹ˆë‹¤.  

* JOIN : nameì„ ë¶™ì´ê¸° ìœ„í•œ ë‹¨ìˆœ inner join 
* GROUP BY : Step2ì—ì„œ ë§Œë“  ì—°ì†ì„±ì„ ëˆ ê·¸ë£¹ê³¼, IDë¥¼ ê¸°ì¤€ìœ¼ë¡œ grouping  
* HAVING : ì´ì œ ì—°ì†ì„±ì„ ëˆ ê·¸ë£¹ì†ì—ì„œ, ê·¸ ë‚ ì§œê°€ 4 ì´ìƒì¸ ê²ƒì„ ì°¾ì•„ì•¼ í•©ë‹ˆë‹¤. ë”°ë¼ì„œ, GROUPì˜ MAX, MINì˜ ì°¨ë¡œ í•„í„°ë§í•©ë‹ˆë‹¤.  

